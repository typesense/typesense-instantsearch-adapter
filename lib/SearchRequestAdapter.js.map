{"version":3,"sources":["../src/SearchRequestAdapter.js"],"names":["SearchRequestAdapter","instantsearchRequests","typesenseClient","configuration","additionalSearchParameters","collectionSpecificSearchParameters","fieldName","collectionName","collectionSpecificFilterByOptions","exactMatch","filterByOptions","facetFilters","adaptedResult","transformedTypesenseFilters","map","item","Array","isArray","intermediateFacetFilters","forEach","facetFilter","_parseFacetFilter","fieldValue","push","Object","keys","length","console","error","join","fieldValues","reduce","result","startsWith","_isNumber","substring","excludedFieldValues","includedFieldValues","typesenseFilterStringComponents","operator","_shouldUseExactMatchForField","v","_escapeFacetValue","typesenseFilterString","filter","f","filterStringMatchingRegex","facetFilterMatches","facetableFieldsWithSpecialCharacters","sanitizedFacetableFieldsWithSpecialCharacters","flat","replace","RegExp","match","constructor","DEFAULT_FACET_FILTER_STRING_MATCHING_REGEX","value","Number","isInteger","numericFilters","filtersHash","_parseNumericFilter","adaptedFilters","field","warn","JSON","stringify","numericFilter","numericFilterMatches","DEFAULT_NUMERIC_FILTER_STRING_MATCHING_REGEX","insideBoundingBox","aroundRadius","aroundLatLng","insidePolygon","x1","y1","x2","y2","split","geoLocationField","Error","adaptedAroundRadius","parseFloat","coordinates","instantsearchParams","filterBy","filters","_adaptFacetFilters","_adaptNumericFilters","_adaptGeoFilter","res","indexName","INDEX_NAME_MATCHING_REGEX","facets","facet","collectionSpecificFacetByOptions","facetByOptions","instantsearchRequest","params","adaptedCollectionName","_adaptIndexName","snakeCasedAdditionalSearchParameters","entries","key","_camelToSnakeCase","typesenseSearchParams","assign","adaptedSortBy","_adaptSortBy","collection","q","query","undefined","facet_by","_adaptFacetBy","filter_by","_adaptFilters","sort_by","max_facet_values","maxValuesPerFacet","page","hitsPerPage","per_page","facetQuery","facet_query","facetName","typesenseVectorQuery","vector_query","fromEntries","_","str","toLowerCase","searches","_buildSearchParameters","multiSearch","perform"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexport class SearchRequestAdapter {\n  static get INDEX_NAME_MATCHING_REGEX() {\n    return new RegExp(\"^(.+?)(?=(/sort/(.*))|$)\");\n  }\n\n  static get DEFAULT_FACET_FILTER_STRING_MATCHING_REGEX() {\n    return new RegExp(\"(.*)((?!:).):(?!:)(.*)\");\n  }\n\n  static get DEFAULT_NUMERIC_FILTER_STRING_MATCHING_REGEX() {\n    return new RegExp(\"(.*?)(<=|>=|>|<|=)(.*)\");\n  }\n\n  constructor(instantsearchRequests, typesenseClient, configuration) {\n    this.instantsearchRequests = instantsearchRequests;\n    this.typesenseClient = typesenseClient;\n    this.configuration = configuration;\n    this.additionalSearchParameters = configuration.additionalSearchParameters;\n    this.collectionSpecificSearchParameters = configuration.collectionSpecificSearchParameters;\n  }\n\n  _shouldUseExactMatchForField(fieldName, collectionName) {\n    if (\n      this.configuration.collectionSpecificFilterByOptions?.[collectionName]?.[fieldName]?.exactMatch === false ||\n      this.configuration.filterByOptions?.[fieldName]?.exactMatch === false\n    ) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  _adaptFacetFilters(facetFilters, collectionName) {\n    let adaptedResult = \"\";\n\n    if (!facetFilters) {\n      return adaptedResult;\n    }\n\n    /**\n     * Need to transform:\n     *  facetFilters = [[\"field1:value1\", \"field1:value2\"], \"field2:value3\", \"field2:value4\"]\n     *\n     * Into this:\n     *  field1:=[value1,value2] && field2:=value3 && field2:=value4\n     *\n     * Steps:\n     *  - For each item in facetFilters\n     *    - If item is array\n     *      - OR values together.\n     *      - Warn if field names are not the same\n     *    - If item is string, convert to facet:=value format\n     *  - Join strings by &&\n     */\n\n    const transformedTypesenseFilters = facetFilters.map((item) => {\n      if (Array.isArray(item)) {\n        // Need to transform:\n        // facetFilters = [\"field1:value1\", \"field1:value2\", \"facetN:valueN\"]\n        //\n        // Into this:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        //     \"fieldN\": [\"valueN\"]\n        // }\n\n        const intermediateFacetFilters = {};\n        item.forEach((facetFilter) => {\n          const { fieldName, fieldValue } = this._parseFacetFilter(facetFilter);\n          intermediateFacetFilters[fieldName] = intermediateFacetFilters[fieldName] || [];\n          intermediateFacetFilters[fieldName].push(fieldValue);\n        });\n\n        if (Object.keys(intermediateFacetFilters).length > 1) {\n          console.error(\n            `[Typesense-Instantsearch-Adapter] Typesense does not support cross-field ORs at the moment. The adapter could not OR values between these fields: ${Object.keys(\n              intermediateFacetFilters\n            ).join(\",\")}`\n          );\n        }\n\n        // Pick first value from intermediateFacetFilters\n        const fieldName = Object.keys(intermediateFacetFilters)[0];\n        const fieldValues = intermediateFacetFilters[fieldName];\n\n        // Need to transform:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        // }\n        //\n        // Into this:\n        // field1:=[value1,value2]\n\n        // Partition values into included and excluded values\n        const [excludedFieldValues, includedFieldValues] = fieldValues.reduce(\n          (result, fieldValue) => {\n            if (fieldValue.startsWith(\"-\") && !this._isNumber(fieldValue)) {\n              result[0].push(fieldValue.substring(1));\n            } else {\n              result[1].push(fieldValue);\n            }\n            return result;\n          },\n          [[], []]\n        );\n\n        const typesenseFilterStringComponents = [];\n        if (includedFieldValues.length > 0) {\n          const operator = this._shouldUseExactMatchForField(fieldName, collectionName) ? \":=\" : \":\";\n          typesenseFilterStringComponents.push(\n            `${fieldName}${operator}[${includedFieldValues.map((v) => this._escapeFacetValue(v)).join(\",\")}]`\n          );\n        }\n        if (excludedFieldValues.length > 0) {\n          const operator = this._shouldUseExactMatchForField(fieldName, collectionName) ? \":!=\" : \":!\";\n          typesenseFilterStringComponents.push(\n            `${fieldName}${operator}[${excludedFieldValues.map((v) => this._escapeFacetValue(v)).join(\",\")}]`\n          );\n        }\n\n        const typesenseFilterString = typesenseFilterStringComponents.filter((f) => f).join(\" && \");\n\n        return typesenseFilterString;\n      } else {\n        // Need to transform:\n        //  fieldName:fieldValue\n        // Into\n        //  fieldName:=fieldValue\n\n        const { fieldName, fieldValue } = this._parseFacetFilter(item);\n        let typesenseFilterString;\n        if (fieldValue.startsWith(\"-\") && !this._isNumber(fieldValue)) {\n          const operator = this._shouldUseExactMatchForField(fieldName, collectionName) ? \":!=\" : \":!\";\n          typesenseFilterString = `${fieldName}${operator}[${this._escapeFacetValue(fieldValue.substring(1))}]`;\n        } else {\n          const operator = this._shouldUseExactMatchForField(fieldName, collectionName) ? \":=\" : \":\";\n          typesenseFilterString = `${fieldName}${operator}[${this._escapeFacetValue(fieldValue)}]`;\n        }\n\n        return typesenseFilterString;\n      }\n    });\n\n    adaptedResult = transformedTypesenseFilters.join(\" && \");\n    return adaptedResult;\n  }\n\n  _parseFacetFilter(facetFilter) {\n    let filterStringMatchingRegex, facetFilterMatches, fieldName, fieldValue;\n\n    // This is helpful when the filter looks like `facetName:with:colons:facetValue:with:colons` and the default regex above parses the filter as `facetName:with:colons:facetValue:with` and `colon`.\n    // So if a facetValue can contain a colon, we ask users to pass in all possible facetable fields in `facetableFieldsWithSpecialCharacters` when instantiating the adapter, so we can explicitly match against that.\n    if (this.configuration.facetableFieldsWithSpecialCharacters?.length > 0) {\n      // escape any Regex special characters, source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n      const sanitizedFacetableFieldsWithSpecialCharacters = this.configuration.facetableFieldsWithSpecialCharacters\n        .flat()\n        .map((f) => f.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"));\n      filterStringMatchingRegex = new RegExp(`^(${sanitizedFacetableFieldsWithSpecialCharacters.join(\"|\")}):(.*)$`);\n      facetFilterMatches = facetFilter.match(filterStringMatchingRegex);\n\n      if (facetFilterMatches != null) {\n        fieldName = `${facetFilterMatches[1]}`;\n        fieldValue = `${facetFilterMatches[2]}`;\n\n        return {\n          fieldName,\n          fieldValue,\n        };\n      }\n    }\n\n    // If we haven't found any matches yet\n    // Use the default filter parsing regex, which assumes that only facet names have colons, and not facet values\n    filterStringMatchingRegex = this.constructor.DEFAULT_FACET_FILTER_STRING_MATCHING_REGEX;\n    facetFilterMatches = facetFilter.match(filterStringMatchingRegex);\n\n    // console.log(filterStringMatchingRegex);\n    // console.log(facetFilter);\n    // console.log(facetFilterMatches);\n\n    if (facetFilterMatches == null) {\n      console.error(\n        `[Typesense-Instantsearch-Adapter] Parsing failed for a facet filter \\`${facetFilter}\\` with the Regex \\`${filterStringMatchingRegex}\\`. If you have field names with special characters, be sure to add them to a parameter called \\`facetableFieldsWithSpecialCharacters\\` when instantiating the adapter.`\n      );\n    } else {\n      fieldName = `${facetFilterMatches[1]}${facetFilterMatches[2]}`;\n      fieldValue = `${facetFilterMatches[3]}`;\n    }\n\n    return {\n      fieldName,\n      fieldValue,\n    };\n  }\n\n  _escapeFacetValue(value) {\n    // Don't escape booleans, integers or floats\n    if (typeof value === \"boolean\" || value === \"true\" || value === \"false\" || this._isNumber(value)) {\n      return value;\n    }\n    return `\\`${value}\\``;\n  }\n\n  _isNumber(value) {\n    return (\n      Number.isInteger(value % 1) || // Mod 1 will automatically try converting string values to integer/float\n      !!(value % 1)\n    ); // Is Float\n  }\n\n  _adaptNumericFilters(numericFilters) {\n    // Need to transform this:\n    // [\"field1<=634\", \"field1>=289\", \"field2<=5\", \"field3>=3\"]\n    // to:\n    // \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    let adaptedResult = \"\";\n\n    if (!numericFilters) {\n      return adaptedResult;\n    }\n\n    // Transform to intermediate structure:\n    // {\n    //   field1: {\n    //     \"<=\": 634,\n    //     \">=\": 289\n    //   },\n    //   field2: {\n    //     \"<=\": 5\n    //   },\n    //   field3: {\n    //     \">=\": 3\n    //   }\n    // };\n    const filtersHash = {};\n    numericFilters.forEach((filter) => {\n      const { fieldName, operator, fieldValue } = this._parseNumericFilter(filter);\n      filtersHash[fieldName] = filtersHash[fieldName] || {};\n      filtersHash[fieldName][operator] = fieldValue;\n    });\n\n    // Transform that to:\n    //  \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    const adaptedFilters = [];\n    Object.keys(filtersHash).forEach((field) => {\n      if (filtersHash[field][\"<=\"] != null && filtersHash[field][\">=\"] != null) {\n        adaptedFilters.push(`${field}:=[${filtersHash[field][\">=\"]}..${filtersHash[field][\"<=\"]}]`);\n      } else if (filtersHash[field][\"<=\"] != null) {\n        adaptedFilters.push(`${field}:<=${filtersHash[field][\"<=\"]}`);\n      } else if (filtersHash[field][\">=\"] != null) {\n        adaptedFilters.push(`${field}:>=${filtersHash[field][\">=\"]}`);\n      } else if (filtersHash[field][\"=\"] != null) {\n        adaptedFilters.push(`${field}:=${filtersHash[field][\"=\"]}`);\n      } else {\n        console.warn(\n          `[Typesense-Instantsearch-Adapter] Unsupported operator found ${JSON.stringify(filtersHash[field])}`\n        );\n      }\n    });\n\n    adaptedResult = adaptedFilters.join(\" && \");\n    return adaptedResult;\n  }\n\n  _parseNumericFilter(numericFilter) {\n    let filterStringMatchingRegex, numericFilterMatches;\n    let fieldName, operator, fieldValue;\n\n    // The following is helpful when the facetName has special characters like > and the default regex fails to parse it properly.\n    // So we ask users to pass in facetable fields in `facetableFieldsWithSpecialCharactersWithSpecialCharacters` when instantiating the adapter, so we can explicitly match against that.\n    if (this.configuration.facetableFieldsWithSpecialCharacters?.length > 0) {\n      // escape any Regex special characters, source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n      const sanitizedFacetableFieldsWithSpecialCharacters = this.configuration.facetableFieldsWithSpecialCharacters.map(\n        (f) => f.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\")\n      );\n      filterStringMatchingRegex = new RegExp(\n        `^(${sanitizedFacetableFieldsWithSpecialCharacters.join(\"|\")})(<=|>=|>|<|=)(.*)$`\n      );\n\n      numericFilterMatches = numericFilter.match(filterStringMatchingRegex);\n\n      if (numericFilterMatches != null) {\n        // If no matches are found or if the above didn't trigger, fall back to the default regex\n        [, fieldName, operator, fieldValue] = numericFilterMatches;\n        return {\n          fieldName,\n          operator,\n          fieldValue,\n        };\n      }\n    }\n\n    // If we haven't found any matches yet, fall back to the default regex\n    filterStringMatchingRegex = this.constructor.DEFAULT_NUMERIC_FILTER_STRING_MATCHING_REGEX;\n    numericFilterMatches = numericFilter.match(filterStringMatchingRegex);\n\n    // console.log(filterStringMatchingRegex);\n    // console.log(numericFilter);\n    // console.log(numericFilterMatches);\n\n    if (numericFilterMatches == null) {\n      console.error(\n        `[Typesense-Instantsearch-Adapter] Parsing failed for a numeric filter \\`${numericFilter}\\` with the Regex \\`${filterStringMatchingRegex}\\`. If you have field names with special characters, be sure to add them to a parameter called \\`facetableFieldsWithSpecialCharacters\\` when instantiating the adapter.`\n      );\n    } else {\n      [, fieldName, operator, fieldValue] = numericFilterMatches;\n    }\n\n    return {\n      fieldName,\n      operator,\n      fieldValue,\n    };\n  }\n\n  _adaptGeoFilter({ insideBoundingBox, aroundRadius, aroundLatLng, insidePolygon }) {\n    // Give this parameter first priority if it exists, since\n    if (insideBoundingBox) {\n      let x1, y1, x2, y2;\n      if (Array.isArray(insideBoundingBox)) {\n        [x1, y1, x2, y2] = insideBoundingBox.flat();\n      } else {\n        [x1, y1, x2, y2] = insideBoundingBox.split(\",\");\n      }\n      return `${this.configuration.geoLocationField}:(${x1}, ${y1}, ${x1}, ${y2}, ${x2}, ${y2}, ${x2}, ${y1})`;\n    }\n\n    if (aroundLatLng || aroundRadius) {\n      if (!aroundRadius || aroundRadius === \"all\") {\n        throw new Error(\n          \"[Typesense-Instantsearch-Adapter] In Typesense, geo-filtering around a lat/lng also requires a numerical radius. \" +\n            \"So the `aroundRadius` parameter is required when `aroundLatLng` is used. \" +\n            \"If you intend to just geo-sort around a lat/long, you want to use the sortBy InstantSearch widget (or a virtual sortBy custom widget).\"\n        );\n      }\n      const adaptedAroundRadius = `${parseFloat(aroundRadius) / 1000} km`; // aroundRadius is in meters\n      return `${this.configuration.geoLocationField}:(${aroundLatLng}, ${adaptedAroundRadius})`;\n    }\n\n    if (insidePolygon) {\n      let coordinates = insidePolygon;\n      if (Array.isArray(insidePolygon)) {\n        coordinates = insidePolygon.flat().join(\",\");\n      }\n      return `${this.configuration.geoLocationField}:(${coordinates})`;\n    }\n  }\n\n  _adaptFilters(instantsearchParams, collectionName, filterBy) {\n    const adaptedFilters = [];\n\n    // `filters` can be used with the `Configure` widget\n    // However the format needs to be in the Typesense filter_by format, instead of Algolia filter format.\n    if (instantsearchParams.filters) {\n      adaptedFilters.push(instantsearchParams.filters);\n    }\n    if (filterBy) adaptedFilters.push(filterBy);\n    adaptedFilters.push(this._adaptFacetFilters(instantsearchParams.facetFilters, collectionName));\n    adaptedFilters.push(this._adaptNumericFilters(instantsearchParams.numericFilters));\n    adaptedFilters.push(this._adaptGeoFilter(instantsearchParams));\n\n    const res = adaptedFilters.filter((filter) => filter && filter !== \"\").join(\" && \");\n    return res;\n  }\n\n  _adaptIndexName(indexName) {\n    return indexName.match(this.constructor.INDEX_NAME_MATCHING_REGEX)[1];\n  }\n\n  _adaptSortBy(indexName) {\n    return indexName.match(this.constructor.INDEX_NAME_MATCHING_REGEX)[3];\n  }\n\n  _adaptFacetBy(facets, collectionName) {\n    return [facets]\n      .flat()\n      .map((facet) => {\n        if (this.configuration.collectionSpecificFacetByOptions?.[collectionName]?.[facet]) {\n          return `${facet}${this.configuration.collectionSpecificFacetByOptions[collectionName][facet]}`;\n        } else if (this.configuration.facetByOptions[facet]) {\n          return `${facet}${this.configuration.facetByOptions[facet]}`;\n        } else {\n          return facet;\n        }\n      })\n      .join(\",\");\n  }\n\n  _buildSearchParameters(instantsearchRequest) {\n    const params = instantsearchRequest.params;\n    const indexName = instantsearchRequest.indexName;\n    const adaptedCollectionName = this._adaptIndexName(indexName);\n\n    // Convert all common parameters to snake case\n    const snakeCasedAdditionalSearchParameters = {};\n    for (const [key, value] of Object.entries(this.additionalSearchParameters)) {\n      snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n    }\n\n    // Override, collection specific parameters\n    if (this.collectionSpecificSearchParameters[adaptedCollectionName]) {\n      for (const [key, value] of Object.entries(this.collectionSpecificSearchParameters[adaptedCollectionName])) {\n        snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n      }\n    }\n\n    const typesenseSearchParams = Object.assign({}, snakeCasedAdditionalSearchParameters);\n\n    const adaptedSortBy = this._adaptSortBy(indexName);\n\n    Object.assign(typesenseSearchParams, {\n      collection: adaptedCollectionName,\n      q: params.query === \"\" || params.query === undefined ? \"*\" : params.query,\n      facet_by:\n        snakeCasedAdditionalSearchParameters.facet_by || this._adaptFacetBy(params.facets, adaptedCollectionName),\n      filter_by:\n        this._adaptFilters(params, adaptedCollectionName, snakeCasedAdditionalSearchParameters.filter_by) ||\n        snakeCasedAdditionalSearchParameters.filter_by,\n\n      sort_by: adaptedSortBy || snakeCasedAdditionalSearchParameters.sort_by,\n      max_facet_values: params.maxValuesPerFacet,\n      page: (params.page || 0) + 1,\n    });\n\n    if (params.hitsPerPage) {\n      typesenseSearchParams.per_page = params.hitsPerPage;\n    }\n\n    if (params.facetQuery) {\n      typesenseSearchParams.facet_query = `${params.facetName}:${params.facetQuery}`;\n      typesenseSearchParams.per_page = 0;\n    }\n\n    // If a custom vector query is specified, set q=*\n    if (params.typesenseVectorQuery) {\n      typesenseSearchParams.vector_query = params.typesenseVectorQuery;\n    }\n\n    // Filter out empty or null values, so we don't accidentally override values set in presets\n    // eslint-disable-next-line no-unused-vars\n    return Object.fromEntries(Object.entries(typesenseSearchParams).filter(([_, v]) => v != null && v !== \"\"));\n  }\n\n  _camelToSnakeCase(str) {\n    return str\n      .split(/(?=[A-Z])/)\n      .join(\"_\")\n      .toLowerCase();\n  }\n\n  async request() {\n    const searches = this.instantsearchRequests.map((instantsearchRequest) =>\n      this._buildSearchParameters(instantsearchRequest)\n    );\n\n    return this.typesenseClient.multiSearch.perform({ searches: searches });\n  }\n}\n"],"file":"SearchRequestAdapter.js"}