{"version":3,"file":"SearchRequestAdapter.js","names":["_objectWithoutProperties","_asyncToGenerator","_toConsumableArray","_slicedToArray","_classCallCheck","_createClass","_excluded","_regeneratorRuntime","SearchRequestAdapter","instantsearchRequests","typesenseClient","configuration","additionalSearchParameters","collectionSpecificSearchParameters","key","value","_shouldUseExactMatchForField","fieldName","collectionName","_this$configuration$c","_this$configuration$f","collectionSpecificFilterByOptions","exactMatch","filterByOptions","_getFacetableFieldsWithSpecialCharacters","fields","facetableFieldsWithSpecialCharacters","Array","isArray","flat","_matchFieldNameWithDelimiter","filter","isDelimiterAtIndex","matches","startsWith","length","map","delimiterIndex","reduce","best","current","_findFacetDelimiterIndex","inBacktick","i","character","_findLastFacetDelimiterIndex","lastIndex","_findNumericOperator","operators","NUMERIC_OPERATORS","index","from","findIndex","some","operator","find","op","_parseJoinFieldName","trimmed","trim","collectionStart","openParenIndex","indexOf","parenCount","closeParenIndex","collection","slice","fieldPath","_parseJoinFilterString","collectionStartsAfterCharIndex","innerFilter","_buildFacetFilterString","_ref","_this","fieldValues","isExcluded","joinedRelationMatch","concat","v","_escapeFacetValue","join","_adaptFacetFilters","facetFilters","_this2","adaptedResult","transformedTypesenseFilters","item","intermediateFacetFilters","forEach","facetFilter","_this2$_parseFacetFil","_parseFacetFilter","fieldValue","push","Object","keys","console","error","_fieldValues$reduce","result","_isNumber","substring","_fieldValues$reduce2","excludedFieldValues","includedFieldValues","typesenseFilterStringComponents","typesenseFilterString","f","_this2$_parseFacetFil2","matched","colonAfterJoin","Number","isInteger","_groupJoinFilters","filters","_this3","joinFiltersMap","regularFilters","joinMatch","groupedJoinFilters","innerFilters","_adaptNumericFilters","numericFilters","_this4","filtersHash","_this4$_parseNumericF","_parseNumericFilter","adaptedFilters","field","warn","JSON","stringify","numericFilter","remainder","trimmedRemainder","trimStart","leadingTrimOffset","opMatch","operatorIndex","_adaptGeoFilter","_ref2","insideBoundingBox","aroundRadius","aroundLatLng","insidePolygon","x1","y1","x2","y2","_insideBoundingBox$fl","_insideBoundingBox$fl2","_insideBoundingBox$sp","split","_insideBoundingBox$sp2","geoLocationField","Error","adaptedAroundRadius","parseFloat","coordinates","_adaptFilters","instantsearchParams","allFilters","flatMap","_adaptIndexName","indexName","sortToken","sortIndex","_adaptSortBy","undefined","_adaptFacetBy","facets","_this5","facet","_this5$configuration$","collectionSpecificFacetByOptions","facetByOptions","_adaptRulesContextsToOverrideTags","ruleContexts","_buildSearchParameters","instantsearchRequest","_this$configuration$c2","_this$configuration$s","params","adaptedCollectionName","snakeCasedAdditionalSearchParameters","_i","_Object$entries","entries","_Object$entries$_i","_camelToSnakeCase","_i2","_Object$entries2","_Object$entries2$_i","typesenseSearchParams","assign","adaptedSortBy","q","query","facet_by","filter_by","sort_by","max_facet_values","maxValuesPerFacet","page","hitsPerPage","per_page","facetQuery","facet_query","facetName","override_tags","typesenseVectorQuery","vector_query","sortByOption","collectionSpecificSortByOptions","sortByOptions","fromEntries","_ref3","_ref4","_","str","toLowerCase","_request","mark","_callee","_this6","_searches$","_searches$2","searches","commonParams","_searches$3","conversation","conversation_id","conversation_model_id","searchRequest","wrap","_callee$","_context","prev","next","searchParams","modifiedSearchParams","union","abrupt","multiSearch","perform","stop","request","apply","arguments","get"],"sources":["../src/SearchRequestAdapter.js"],"sourcesContent":["\"use strict\";\n\nexport class SearchRequestAdapter {\n  static get NUMERIC_OPERATORS() {\n    return [\"<=\", \">=\", \"<\", \">\", \"=\"];\n  }\n\n  constructor(instantsearchRequests, typesenseClient, configuration) {\n    this.instantsearchRequests = instantsearchRequests;\n    this.typesenseClient = typesenseClient;\n    this.configuration = configuration;\n    this.additionalSearchParameters = configuration.additionalSearchParameters;\n    this.collectionSpecificSearchParameters = configuration.collectionSpecificSearchParameters;\n  }\n\n  _shouldUseExactMatchForField(fieldName, collectionName) {\n    if (\n      this.configuration.collectionSpecificFilterByOptions?.[collectionName]?.[fieldName]?.exactMatch === false ||\n      this.configuration.filterByOptions?.[fieldName]?.exactMatch === false\n    ) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Returns the configured list of field names that may include delimiters.\n   * Always returns a flat array so callers can treat it uniformly.\n   */\n  _getFacetableFieldsWithSpecialCharacters() {\n    const fields = this.configuration.facetableFieldsWithSpecialCharacters;\n    if (!Array.isArray(fields)) {\n      return [];\n    }\n    return fields.flat();\n  }\n\n  /**\n   * Finds the best matching field name at the start of `filter`.\n   * Uses the provided delimiter check so it works for both facets and numeric filters.\n   */\n  _matchFieldNameWithDelimiter(filter, fields, isDelimiterAtIndex) {\n    const matches = fields\n      .filter((fieldName) => filter.startsWith(fieldName) && isDelimiterAtIndex(fieldName.length))\n      .map((fieldName) => ({\n        fieldName,\n        delimiterIndex: fieldName.length,\n      }));\n\n    if (matches.length === 0) {\n      return null;\n    }\n\n    return matches.reduce((best, current) => (current.fieldName.length > best.fieldName.length ? current : best));\n  }\n\n  /**\n   * Returns the index of the first \":\" that is not inside backticks.\n   */\n  _findFacetDelimiterIndex(filter) {\n    let inBacktick = false;\n    for (let i = 0; i < filter.length; i += 1) {\n      const character = filter[i];\n      if (character === \"`\") {\n        inBacktick = !inBacktick;\n      }\n      if (!inBacktick && character === \":\") {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the index of the last \":\" that is not inside backticks.\n   * Used as a fallback when field names may contain colons.\n   */\n  _findLastFacetDelimiterIndex(filter) {\n    let inBacktick = false;\n    let lastIndex = -1;\n    for (let i = 0; i < filter.length; i += 1) {\n      const character = filter[i];\n      if (character === \"`\") {\n        inBacktick = !inBacktick;\n      }\n      if (!inBacktick && character === \":\") {\n        lastIndex = i;\n      }\n    }\n    return lastIndex;\n  }\n\n  /**\n   * Finds the first numeric operator outside backticks and returns its position.\n   * @param {string} filter\n   */\n  _findNumericOperator(filter) {\n    const operators = SearchRequestAdapter.NUMERIC_OPERATORS;\n    let inBacktick = false;\n\n    const index = Array.from(filter).findIndex((character, i) => {\n      if (character === \"`\") {\n        inBacktick = !inBacktick;\n      }\n      if (inBacktick) {\n        return false;\n      }\n      return operators.some((operator) => filter.startsWith(operator, i));\n    });\n\n    if (index === -1) {\n      return null;\n    }\n\n    const operator = operators.find((op) => filter.startsWith(op, index));\n    return { index, operator };\n  }\n\n  /**\n   * Parses \"$collection(field.path)\" (or \"!$collection(field.path)\").\n   * Example: \"$product_prices(retailer)\" -> { collection: \"product_prices\", fieldPath: \"retailer\" }\n   * Returns null if the string is not a join field.\n   * @param {string} fieldName\n   */\n  _parseJoinFieldName(fieldName) {\n    const trimmed = fieldName.trim();\n    if (!(trimmed.startsWith(\"$\") || trimmed.startsWith(\"!$\"))) {\n      return null;\n    }\n    const collectionStart = trimmed.startsWith(\"!$\") ? 2 : 1;\n    const openParenIndex = trimmed.indexOf(\"(\", collectionStart);\n    if (openParenIndex === -1) {\n      return null;\n    }\n\n    let parenCount = 0;\n    let closeParenIndex = -1;\n    for (let i = openParenIndex; i < trimmed.length; i += 1) {\n      const character = trimmed[i];\n      if (character === \"(\") {\n        parenCount += 1;\n      } else if (character === \")\") {\n        parenCount -= 1;\n        if (parenCount === 0) {\n          closeParenIndex = i;\n          break;\n        }\n      }\n    }\n\n    if (closeParenIndex === -1 || closeParenIndex !== trimmed.length - 1) {\n      return null;\n    }\n\n    const collection = trimmed.slice(0, openParenIndex).trim();\n    const fieldPath = trimmed.slice(openParenIndex + 1, closeParenIndex).trim();\n    if (!collection || !fieldPath) {\n      return null;\n    }\n\n    return { collection, fieldPath };\n  }\n\n  /**\n   * Parses \"$collection(innerFilter)\" (or \"!$collection(innerFilter)\").\n   * Example: \"$product_prices(retailer:=[`value1`])\" -> { collection: \"product_prices\", innerFilter: \"retailer:=[`value1`]\" }\n   * Returns null if the filter is not a join filter string or parsing fails.\n   * @param {string} filter\n   */\n  _parseJoinFilterString(filter) {\n    const trimmed = filter.trim();\n    if (!(trimmed.startsWith(\"$\") || trimmed.startsWith(\"!$\"))) {\n      return null;\n    }\n    const collectionStartsAfterCharIndex = trimmed.startsWith(\"!$\") ? 2 : 1;\n    const openParenIndex = trimmed.indexOf(\"(\", collectionStartsAfterCharIndex);\n    if (openParenIndex === -1) {\n      return null;\n    }\n\n    let parenCount = 0;\n    let closeParenIndex = -1;\n    for (let i = openParenIndex; i < trimmed.length; i += 1) {\n      const character = trimmed[i];\n      if (character === \"(\") {\n        parenCount += 1;\n      } else if (character === \")\") {\n        parenCount -= 1;\n        if (parenCount === 0) {\n          closeParenIndex = i;\n          break;\n        }\n      }\n    }\n\n    if (closeParenIndex === -1 || closeParenIndex !== trimmed.length - 1) {\n      return null;\n    }\n\n    const collection = trimmed.slice(0, openParenIndex).trim();\n    const innerFilter = trimmed.slice(openParenIndex + 1, closeParenIndex).trim();\n    if (!collection || !innerFilter) {\n      return null;\n    }\n\n    return { collection, innerFilter };\n  }\n\n  _buildFacetFilterString({ fieldName, fieldValues, isExcluded, collectionName }) {\n    // Check if this is a joined relation filter (e.g., \"$refCollection(retailer)\")\n    const joinedRelationMatch = this._parseJoinFieldName(fieldName);\n\n    const operator = isExcluded\n      ? this._shouldUseExactMatchForField(fieldName, collectionName)\n        ? \":!=\"\n        : \":!\"\n      : this._shouldUseExactMatchForField(fieldName, collectionName)\n        ? \":=\"\n        : \":\";\n\n    if (joinedRelationMatch) {\n      // This is a joined relation filter\n      const { collection, fieldPath } = joinedRelationMatch; // e.g., \"$refCollection\", \"retailer\"\n      // For joined relations, the filter should be: $collection(field:=[value1,value2])\n      return `${collection}(${fieldPath}${operator}[${fieldValues.map((v) => this._escapeFacetValue(v)).join(\",\")}])`;\n    } else {\n      // Regular field filter (non-joined)\n      return `${fieldName}${operator}[${fieldValues.map((v) => this._escapeFacetValue(v)).join(\",\")}]`;\n    }\n  }\n\n  _adaptFacetFilters(facetFilters, collectionName) {\n    let adaptedResult = \"\";\n\n    if (!facetFilters) {\n      return adaptedResult;\n    }\n\n    /**\n     * Need to transform:\n     *  facetFilters = [[\"field1:value1\", \"field1:value2\"], \"field2:value3\", \"field2:value4\"]\n     *\n     * Into this:\n     *  field1:=[value1,value2] && field2:=value3 && field2:=value4\n     *\n     * Steps:\n     *  - For each item in facetFilters\n     *    - If item is array\n     *      - OR values together.\n     *      - Warn if field names are not the same\n     *    - If item is string, convert to facet:=value format\n     *  - Join strings by &&\n     */\n\n    const transformedTypesenseFilters = facetFilters.map((item) => {\n      if (Array.isArray(item)) {\n        // Need to transform:\n        // facetFilters = [\"field1:value1\", \"field1:value2\", \"facetN:valueN\"]\n        //\n        // Into this:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        //     \"fieldN\": [\"valueN\"]\n        // }\n\n        const intermediateFacetFilters = {};\n        item.forEach((facetFilter) => {\n          const { fieldName, fieldValue } = this._parseFacetFilter(facetFilter);\n          intermediateFacetFilters[fieldName] = intermediateFacetFilters[fieldName] || [];\n          intermediateFacetFilters[fieldName].push(fieldValue);\n        });\n\n        if (Object.keys(intermediateFacetFilters).length > 1) {\n          console.error(\n            `[Typesense-Instantsearch-Adapter] Typesense does not support cross-field ORs at the moment. The adapter could not OR values between these fields: ${Object.keys(\n              intermediateFacetFilters,\n            ).join(\",\")}`,\n          );\n        }\n\n        // Pick first value from intermediateFacetFilters\n        const fieldName = Object.keys(intermediateFacetFilters)[0];\n        const fieldValues = intermediateFacetFilters[fieldName];\n\n        // Need to transform:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        // }\n        //\n        // Into this:\n        // field1:=[value1,value2]\n\n        // Partition values into included and excluded values\n        const [excludedFieldValues, includedFieldValues] = fieldValues.reduce(\n          (result, fieldValue) => {\n            if (fieldValue.startsWith(\"-\") && !this._isNumber(fieldValue)) {\n              result[0].push(fieldValue.substring(1));\n            } else {\n              result[1].push(fieldValue);\n            }\n            return result;\n          },\n          [[], []],\n        );\n\n        const typesenseFilterStringComponents = [];\n        if (includedFieldValues.length > 0) {\n          typesenseFilterStringComponents.push(\n            this._buildFacetFilterString({\n              fieldName,\n              fieldValues: includedFieldValues,\n              isExcluded: false,\n              collectionName,\n            }),\n          );\n        }\n        if (excludedFieldValues.length > 0) {\n          typesenseFilterStringComponents.push(\n            this._buildFacetFilterString({\n              fieldName,\n              fieldValues: excludedFieldValues,\n              isExcluded: true,\n              collectionName,\n            }),\n          );\n        }\n\n        const typesenseFilterString = typesenseFilterStringComponents.filter((f) => f).join(\" && \");\n\n        return typesenseFilterString;\n      } else {\n        // Need to transform:\n        //  fieldName:fieldValue\n        // Into\n        //  fieldName:=fieldValue\n\n        const { fieldName, fieldValue } = this._parseFacetFilter(item);\n        let typesenseFilterString;\n        if (fieldValue.startsWith(\"-\") && !this._isNumber(fieldValue)) {\n          typesenseFilterString = this._buildFacetFilterString({\n            fieldName,\n            fieldValues: [fieldValue.substring(1)],\n            isExcluded: true,\n            collectionName,\n          });\n        } else {\n          typesenseFilterString = this._buildFacetFilterString({\n            fieldName,\n            fieldValues: [fieldValue],\n            isExcluded: false,\n            collectionName,\n          });\n        }\n\n        return typesenseFilterString;\n      }\n    });\n\n    adaptedResult = transformedTypesenseFilters.join(\" && \");\n    // console.log(`${JSON.stringify(facetFilters)} => ${adaptedResult}`);\n\n    return adaptedResult;\n  }\n\n  _parseFacetFilter(facetFilter) {\n    let fieldName, fieldValue;\n\n    // This is helpful when the filter looks like `facetName:with:colons:facetValue:with:colons` and a naive split would parse it as `facetName:with:colons:facetValue:with` and `colon`.\n    // So if a facetValue can contain a colon, we ask users to pass in all possible facetable fields in `facetableFieldsWithSpecialCharacters` when instantiating the adapter, so we can explicitly match against that.\n    const facetableFieldsWithSpecialCharacters = this._getFacetableFieldsWithSpecialCharacters();\n    if (facetableFieldsWithSpecialCharacters.length > 0) {\n      const matched = this._matchFieldNameWithDelimiter(\n        facetFilter,\n        facetableFieldsWithSpecialCharacters,\n        (index) => facetFilter[index] === \":\",\n      );\n      if (matched) {\n        fieldName = matched.fieldName;\n        fieldValue = facetFilter.slice(matched.delimiterIndex + 1);\n        return {\n          fieldName,\n          fieldValue,\n        };\n      }\n    }\n\n    // If we haven't found any matches yet, check if this is a join filter\n    // JOIN filters have the format \"$collection(field):value\" or \"!$collection(field):value\" (https://typesense.org/docs/latest/api/search.html#facet-referencing)\n    // for join filters, we need to find the colon after the closing parenthesis, not use the last colon\n    if (facetFilter.startsWith(\"$\") || facetFilter.startsWith(\"!$\")) {\n      const collectionStartsAfterCharIndex = facetFilter.startsWith(\"!$\") ? 2 : 1;\n      const openParenIndex = facetFilter.indexOf(\"(\", collectionStartsAfterCharIndex);\n      if (openParenIndex !== -1) {\n        // find the matching closing parenthesis\n        let parenCount = 0;\n        let closeParenIndex = -1;\n        for (let i = openParenIndex; i < facetFilter.length; i += 1) {\n          const character = facetFilter[i];\n          if (character === \"(\") {\n            parenCount += 1;\n          } else if (character === \")\") {\n            parenCount -= 1;\n            if (parenCount === 0) {\n              closeParenIndex = i;\n              break;\n            }\n          }\n        }\n        // found a closing paren, find the colon after it\n        if (closeParenIndex !== -1) {\n          const colonAfterJoin = facetFilter.indexOf(\":\", closeParenIndex + 1);\n          if (colonAfterJoin !== -1) {\n            fieldName = facetFilter.slice(0, colonAfterJoin).trim();\n            fieldValue = facetFilter.slice(colonAfterJoin + 1).trim();\n            return {\n              fieldName,\n              fieldValue,\n            };\n          }\n        }\n      }\n    }\n\n    // use a scan that assumes field names may have colons so we use the last colon as the delimiter.\n    // handles cases like \"field2:with:colons:value3\" where the field name is \"field2:with:colons\". (edge case, not sure if this is supported by the server)\n    const delimiterIndex = this._findLastFacetDelimiterIndex(facetFilter);\n    if (delimiterIndex === -1) {\n      console.error(\n        `[Typesense-Instantsearch-Adapter] Parsing failed for a facet filter \\`${facetFilter}\\`. If you have field names with special characters, add them to a parameter called \\`facetableFieldsWithSpecialCharacters\\` when instantiating the adapter.`,\n      );\n    } else {\n      fieldName = facetFilter.slice(0, delimiterIndex).trim();\n      fieldValue = facetFilter.slice(delimiterIndex + 1).trim();\n    }\n\n    return {\n      fieldName,\n      fieldValue,\n    };\n  }\n\n  _escapeFacetValue(value) {\n    // Don't escape booleans, integers or floats\n    if (typeof value === \"boolean\" || value === \"true\" || value === \"false\" || this._isNumber(value)) {\n      return value;\n    }\n    return `\\`${value}\\``;\n  }\n\n  _isNumber(value) {\n    return (\n      Number.isInteger(value % 1) || // Mod 1 will automatically try converting string values to integer/float\n      !!(value % 1)\n    ); // Is Float\n  }\n\n  _groupJoinFilters(filters) {\n    // Group join filters by their collection name\n    // Example: [\"$product_prices(retailer:=[`value1`])\", \"$product_prices(status:=[`active`])\", \"brand:=[`Apple`]\"]\n    // Should become: [\"$product_prices(retailer:=[`value1`] && status:=[`active`])\", \"brand:=[`Apple`]\"]\n\n    const joinFiltersMap = {};\n    const regularFilters = [];\n\n    filters.forEach((filter) => {\n      const joinMatch = this._parseJoinFilterString(filter);\n\n      if (joinMatch) {\n        const { collection, innerFilter } = joinMatch;\n\n        if (!joinFiltersMap[collection]) {\n          joinFiltersMap[collection] = [];\n        }\n        joinFiltersMap[collection].push(innerFilter);\n      } else {\n        regularFilters.push(filter);\n      }\n    });\n\n    // Rebuild grouped join filters\n    const groupedJoinFilters = Object.keys(joinFiltersMap).map((collection) => {\n      const innerFilters = joinFiltersMap[collection].join(\" && \");\n      return `${collection}(${innerFilters})`;\n    });\n\n    // Combine grouped join filters with regular filters\n    return [...groupedJoinFilters, ...regularFilters].filter((f) => f).join(\" && \");\n  }\n\n  _adaptNumericFilters(numericFilters) {\n    // Need to transform this:\n    // [\"field1<=634\", \"field1>=289\", \"field2<=5\", \"field3>=3\"]\n    // to:\n    // \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    let adaptedResult = \"\";\n\n    if (!numericFilters) {\n      return adaptedResult;\n    }\n\n    // Transform to intermediate structure:\n    // {\n    //   field1: {\n    //     \"<=\": 634,\n    //     \">=\": 289\n    //   },\n    //   field2: {\n    //     \"<=\": 5\n    //   },\n    //   field3: {\n    //     \">=\": 3\n    //   }\n    // };\n    const filtersHash = {};\n    numericFilters.forEach((filter) => {\n      const { fieldName, operator, fieldValue } = this._parseNumericFilter(filter);\n      filtersHash[fieldName] = filtersHash[fieldName] || {};\n      filtersHash[fieldName][operator] = fieldValue;\n    });\n\n    // Transform that to:\n    //  \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    const adaptedFilters = [];\n    Object.keys(filtersHash).forEach((field) => {\n      // Check if this is a joined relation filter (e.g., \"$refCollection(price.current)\")\n      const joinedRelationMatch = this._parseJoinFieldName(field);\n\n      if (joinedRelationMatch) {\n        // This is a joined relation filter\n        const { collection, fieldPath } = joinedRelationMatch; // e.g., \"$refCollection\", \"price.current\"\n\n        if (filtersHash[field][\"<=\"] != null && filtersHash[field][\">=\"] != null) {\n          adaptedFilters.push(\n            `${collection}(${fieldPath}:=[${filtersHash[field][\">=\"]}..${filtersHash[field][\"<=\"]}])`,\n          );\n        } else if (filtersHash[field][\"<=\"] != null) {\n          adaptedFilters.push(`${collection}(${fieldPath}:<=${filtersHash[field][\"<=\"]})`);\n        } else if (filtersHash[field][\">=\"] != null) {\n          adaptedFilters.push(`${collection}(${fieldPath}:>=${filtersHash[field][\">=\"]})`);\n        } else if (filtersHash[field][\"=\"] != null) {\n          adaptedFilters.push(`${collection}(${fieldPath}:=${filtersHash[field][\"=\"]})`);\n        } else {\n          console.warn(\n            `[Typesense-Instantsearch-Adapter] Unsupported operator found ${JSON.stringify(filtersHash[field])}`,\n          );\n        }\n      } else {\n        // Regular field filter (non-joined)\n        if (filtersHash[field][\"<=\"] != null && filtersHash[field][\">=\"] != null) {\n          adaptedFilters.push(`${field}:=[${filtersHash[field][\">=\"]}..${filtersHash[field][\"<=\"]}]`);\n        } else if (filtersHash[field][\"<=\"] != null) {\n          adaptedFilters.push(`${field}:<=${filtersHash[field][\"<=\"]}`);\n        } else if (filtersHash[field][\">=\"] != null) {\n          adaptedFilters.push(`${field}:>=${filtersHash[field][\">=\"]}`);\n        } else if (filtersHash[field][\"=\"] != null) {\n          adaptedFilters.push(`${field}:=${filtersHash[field][\"=\"]}`);\n        } else {\n          console.warn(\n            `[Typesense-Instantsearch-Adapter] Unsupported operator found ${JSON.stringify(filtersHash[field])}`,\n          );\n        }\n      }\n    });\n\n    adaptedResult = adaptedFilters.join(\" && \");\n    return adaptedResult;\n  }\n\n  _parseNumericFilter(numericFilter) {\n    let fieldName, operator, fieldValue;\n\n    // The following is helpful when the facetName has special characters like > and a naive operator scan would parse it improperly.\n    // So we ask users to pass in facetable fields in `facetableFieldsWithSpecialCharactersWithSpecialCharacters` when instantiating the adapter, so we can explicitly match against that.\n    const facetableFieldsWithSpecialCharacters = this._getFacetableFieldsWithSpecialCharacters();\n    if (facetableFieldsWithSpecialCharacters.length > 0) {\n      const matched = this._matchFieldNameWithDelimiter(\n        numericFilter,\n        facetableFieldsWithSpecialCharacters,\n        () => true,\n      );\n      if (matched) {\n        const remainder = numericFilter.slice(matched.delimiterIndex);\n        const trimmedRemainder = remainder.trimStart();\n        const leadingTrimOffset = remainder.length - trimmedRemainder.length;\n        const opMatch = this._findNumericOperator(trimmedRemainder);\n        if (opMatch && opMatch.index === 0) {\n          const operatorIndex = matched.delimiterIndex + leadingTrimOffset;\n          fieldName = numericFilter.slice(0, operatorIndex).trim();\n          operator = opMatch.operator;\n          fieldValue = trimmedRemainder.slice(opMatch.operator.length).trim();\n          return {\n            fieldName,\n            operator,\n            fieldValue,\n          };\n        }\n      }\n    }\n\n    // If we haven't found any matches yet, fall back to scanning for an operator.\n    const opMatch = this._findNumericOperator(numericFilter);\n    if (!opMatch) {\n      console.error(\n        `[Typesense-Instantsearch-Adapter] Parsing failed for a numeric filter \\`${numericFilter}\\`. If you have field names with special characters, be sure to add them to a parameter called \\`facetableFieldsWithSpecialCharacters\\` when instantiating the adapter.`,\n      );\n    } else {\n      fieldName = numericFilter.slice(0, opMatch.index).trim();\n      operator = opMatch.operator;\n      fieldValue = numericFilter.slice(opMatch.index + opMatch.operator.length).trim();\n    }\n\n    return {\n      fieldName,\n      operator,\n      fieldValue,\n    };\n  }\n\n  _adaptGeoFilter({ insideBoundingBox, aroundRadius, aroundLatLng, insidePolygon }) {\n    // Give this parameter first priority if it exists, since\n    if (insideBoundingBox) {\n      let x1, y1, x2, y2;\n      if (Array.isArray(insideBoundingBox)) {\n        [x1, y1, x2, y2] = insideBoundingBox.flat();\n      } else {\n        [x1, y1, x2, y2] = insideBoundingBox.split(\",\");\n      }\n      return `${this.configuration.geoLocationField}:(${x1}, ${y1}, ${x1}, ${y2}, ${x2}, ${y2}, ${x2}, ${y1})`;\n    }\n\n    if (aroundLatLng || aroundRadius) {\n      if (!aroundRadius || aroundRadius === \"all\") {\n        throw new Error(\n          \"[Typesense-Instantsearch-Adapter] In Typesense, geo-filtering around a lat/lng also requires a numerical radius. \" +\n            \"So the `aroundRadius` parameter is required when `aroundLatLng` is used. \" +\n            \"If you intend to just geo-sort around a lat/long, you want to use the sortBy InstantSearch widget (or a virtual sortBy custom widget).\",\n        );\n      }\n      const adaptedAroundRadius = `${parseFloat(aroundRadius) / 1000} km`; // aroundRadius is in meters\n      return `${this.configuration.geoLocationField}:(${aroundLatLng}, ${adaptedAroundRadius})`;\n    }\n\n    if (insidePolygon) {\n      let coordinates = insidePolygon;\n      if (Array.isArray(insidePolygon)) {\n        coordinates = insidePolygon.flat().join(\",\");\n      }\n      return `${this.configuration.geoLocationField}:(${coordinates})`;\n    }\n  }\n\n  _adaptFilters(instantsearchParams, collectionName) {\n    const adaptedFilters = [];\n\n    // `filters` can be used with the `Configure` widget\n    // However the format needs to be in the Typesense filter_by format, instead of Algolia filter format.\n    if (instantsearchParams.filters) {\n      adaptedFilters.push(instantsearchParams.filters);\n    }\n    adaptedFilters.push(this._adaptFacetFilters(instantsearchParams.facetFilters, collectionName));\n    adaptedFilters.push(this._adaptNumericFilters(instantsearchParams.numericFilters));\n    adaptedFilters.push(this._adaptGeoFilter(instantsearchParams));\n\n    // Filter out empty strings, split by && to get individual filters, then group join filters\n    const allFilters = adaptedFilters\n      .filter((filter) => filter && filter !== \"\")\n      .flatMap((filter) => filter.split(\" && \").map((f) => f.trim()))\n      .filter((f) => f);\n\n    return this._groupJoinFilters(allFilters);\n  }\n\n  _adaptIndexName(indexName) {\n    const sortToken = \"/sort/\";\n    const sortIndex = indexName.indexOf(sortToken);\n    if (sortIndex === -1) {\n      return indexName;\n    }\n    return indexName.slice(0, sortIndex);\n  }\n\n  _adaptSortBy(indexName) {\n    const sortToken = \"/sort/\";\n    const sortIndex = indexName.indexOf(sortToken);\n    if (sortIndex === -1) {\n      return undefined;\n    }\n    return indexName.slice(sortIndex + sortToken.length);\n  }\n\n  _adaptFacetBy(facets, collectionName) {\n    return [facets]\n      .flat()\n      .map((facet) => {\n        if (this.configuration.collectionSpecificFacetByOptions?.[collectionName]?.[facet]) {\n          return `${facet}${this.configuration.collectionSpecificFacetByOptions[collectionName][facet]}`;\n        } else if (this.configuration.facetByOptions[facet]) {\n          return `${facet}${this.configuration.facetByOptions[facet]}`;\n        } else {\n          return facet;\n        }\n      })\n      .join(\",\");\n  }\n\n  _adaptRulesContextsToOverrideTags(ruleContexts) {\n    return ruleContexts.join(\",\");\n  }\n\n  _buildSearchParameters(instantsearchRequest) {\n    const params = instantsearchRequest.params;\n    const indexName = instantsearchRequest.indexName;\n    const adaptedCollectionName = this._adaptIndexName(indexName);\n\n    // Convert all common parameters to snake case\n    const snakeCasedAdditionalSearchParameters = {};\n    for (const [key, value] of Object.entries(this.additionalSearchParameters)) {\n      snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n    }\n\n    // Override, collection specific parameters\n    if (this.collectionSpecificSearchParameters[adaptedCollectionName]) {\n      for (const [key, value] of Object.entries(this.collectionSpecificSearchParameters[adaptedCollectionName])) {\n        snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n      }\n    }\n\n    const typesenseSearchParams = Object.assign({}, snakeCasedAdditionalSearchParameters);\n\n    const adaptedSortBy = this._adaptSortBy(indexName);\n\n    Object.assign(typesenseSearchParams, {\n      collection: adaptedCollectionName,\n      q: params.query === \"\" || params.query === undefined ? \"*\" : params.query,\n      facet_by:\n        snakeCasedAdditionalSearchParameters.facet_by || this._adaptFacetBy(params.facets, adaptedCollectionName),\n      filter_by: this._adaptFilters(params, adaptedCollectionName) || snakeCasedAdditionalSearchParameters.filter_by,\n      sort_by: adaptedSortBy || snakeCasedAdditionalSearchParameters.sort_by,\n      max_facet_values: params.maxValuesPerFacet,\n      page: (params.page || 0) + 1,\n    });\n\n    if (params.hitsPerPage != null) {\n      typesenseSearchParams.per_page = params.hitsPerPage;\n    }\n\n    if (params.facetQuery) {\n      typesenseSearchParams.facet_query = `${params.facetName}:${params.facetQuery}`;\n      typesenseSearchParams.per_page = 0;\n    }\n\n    if (params.ruleContexts && params.ruleContexts.length > 0) {\n      typesenseSearchParams.override_tags = this._adaptRulesContextsToOverrideTags(params.ruleContexts);\n    }\n\n    // If a custom vector query is specified, set q=*\n    if (params.typesenseVectorQuery) {\n      typesenseSearchParams.vector_query = params.typesenseVectorQuery;\n    }\n\n    // Allow for conditional disabling of overrides, for particular sort orders\n    let sortByOption =\n      this.configuration.collectionSpecificSortByOptions?.[adaptedCollectionName]?.[typesenseSearchParams[\"sort_by\"]] ||\n      this.configuration.sortByOptions?.[typesenseSearchParams[\"sort_by\"]];\n    if (sortByOption?.[\"enable_overrides\"] != null) {\n      typesenseSearchParams[\"enable_overrides\"] = sortByOption[\"enable_overrides\"];\n    }\n\n    // console.log(params);\n    // console.log(typesenseSearchParams);\n\n    // Filter out empty or null values, so we don't accidentally override values set in presets\n    // eslint-disable-next-line no-unused-vars\n    return Object.fromEntries(Object.entries(typesenseSearchParams).filter(([_, v]) => v != null && v !== \"\"));\n  }\n\n  _camelToSnakeCase(str) {\n    return str\n      .split(/(?=[A-Z])/)\n      .join(\"_\")\n      .toLowerCase();\n  }\n\n  async request() {\n    // console.log(this.instantsearchRequests);\n\n    let searches = this.instantsearchRequests.map((instantsearchRequest) =>\n      this._buildSearchParameters(instantsearchRequest),\n    );\n\n    // If this is a conversational search, then move conversation related params to query params\n    let commonParams = {};\n    if (searches[0]?.conversation === true || searches[0]?.conversation === \"true\") {\n      const { q, conversation, conversation_id, conversation_model_id } = searches[0];\n      commonParams = { q, conversation, conversation_id, conversation_model_id };\n\n      searches = searches.map((searchParams) => {\n        // eslint-disable-next-line no-unused-vars\n        const { q, conversation, conversation_id, conversation_model_id, ...modifiedSearchParams } = searchParams;\n        return modifiedSearchParams;\n      });\n    }\n\n    const searchRequest = { searches: searches };\n\n    // Add union parameter if configured\n    if (this.configuration.union) {\n      searchRequest.union = this.configuration.union;\n      commonParams.page = searches[0].page;\n    }\n\n    return this.typesenseClient.multiSearch.perform(searchRequest, commonParams);\n  }\n}\n"],"mappings":"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","ignoreList":[]}